/*
 * generated by Xtext 2.26.0
 */
package dk.sdu.frhou18.mdsd.serializer;

import com.google.inject.Inject;
import dk.sdu.frhou18.mdsd.iF22.And;
import dk.sdu.frhou18.mdsd.iF22.Announce;
import dk.sdu.frhou18.mdsd.iF22.Division;
import dk.sdu.frhou18.mdsd.iF22.End;
import dk.sdu.frhou18.mdsd.iF22.Equals;
import dk.sdu.frhou18.mdsd.iF22.Function;
import dk.sdu.frhou18.mdsd.iF22.FunctionUsage;
import dk.sdu.frhou18.mdsd.iF22.Greater;
import dk.sdu.frhou18.mdsd.iF22.GreaterOrEquals;
import dk.sdu.frhou18.mdsd.iF22.IF22Package;
import dk.sdu.frhou18.mdsd.iF22.Less;
import dk.sdu.frhou18.mdsd.iF22.LessOrEquals;
import dk.sdu.frhou18.mdsd.iF22.LogicNot;
import dk.sdu.frhou18.mdsd.iF22.MathNumberExp;
import dk.sdu.frhou18.mdsd.iF22.Minus;
import dk.sdu.frhou18.mdsd.iF22.Model;
import dk.sdu.frhou18.mdsd.iF22.Multiplication;
import dk.sdu.frhou18.mdsd.iF22.NotEquals;
import dk.sdu.frhou18.mdsd.iF22.Or;
import dk.sdu.frhou18.mdsd.iF22.Parentheses;
import dk.sdu.frhou18.mdsd.iF22.Plus;
import dk.sdu.frhou18.mdsd.iF22.Question;
import dk.sdu.frhou18.mdsd.iF22.Scenario;
import dk.sdu.frhou18.mdsd.iF22.Story;
import dk.sdu.frhou18.mdsd.iF22.Target;
import dk.sdu.frhou18.mdsd.iF22.TextExp;
import dk.sdu.frhou18.mdsd.iF22.TextLiteral;
import dk.sdu.frhou18.mdsd.iF22.This;
import dk.sdu.frhou18.mdsd.iF22.TypeUsage;
import dk.sdu.frhou18.mdsd.iF22.VarUse;
import dk.sdu.frhou18.mdsd.iF22.VariableDef;
import dk.sdu.frhou18.mdsd.services.IF22GrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class IF22SemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private IF22GrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == IF22Package.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case IF22Package.AND:
				sequence_LogicAndOR(context, (And) semanticObject); 
				return; 
			case IF22Package.ANNOUNCE:
				sequence_Announce(context, (Announce) semanticObject); 
				return; 
			case IF22Package.BOOLEAN:
				sequence_Boolean(context, (dk.sdu.frhou18.mdsd.iF22.Boolean) semanticObject); 
				return; 
			case IF22Package.DIVISION:
				sequence_MultDivMathExp(context, (Division) semanticObject); 
				return; 
			case IF22Package.END:
				sequence_End(context, (End) semanticObject); 
				return; 
			case IF22Package.EQUALS:
				sequence_LogicExp(context, (Equals) semanticObject); 
				return; 
			case IF22Package.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case IF22Package.FUNCTION_USAGE:
				sequence_FunctionUsage(context, (FunctionUsage) semanticObject); 
				return; 
			case IF22Package.GREATER:
				sequence_LogicExp(context, (Greater) semanticObject); 
				return; 
			case IF22Package.GREATER_OR_EQUALS:
				sequence_LogicExp(context, (GreaterOrEquals) semanticObject); 
				return; 
			case IF22Package.LESS:
				sequence_LogicExp(context, (Less) semanticObject); 
				return; 
			case IF22Package.LESS_OR_EQUALS:
				sequence_LogicExp(context, (LessOrEquals) semanticObject); 
				return; 
			case IF22Package.LOGIC_NOT:
				sequence_LogicNot(context, (LogicNot) semanticObject); 
				return; 
			case IF22Package.MATH_NUMBER_EXP:
				sequence_MathNumberExp(context, (MathNumberExp) semanticObject); 
				return; 
			case IF22Package.MINUS:
				sequence_MathExp(context, (Minus) semanticObject); 
				return; 
			case IF22Package.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case IF22Package.MULTIPLICATION:
				sequence_MultDivMathExp(context, (Multiplication) semanticObject); 
				return; 
			case IF22Package.NOT_EQUALS:
				sequence_LogicExp(context, (NotEquals) semanticObject); 
				return; 
			case IF22Package.OR:
				sequence_LogicAndOR(context, (Or) semanticObject); 
				return; 
			case IF22Package.PARENTHESES:
				sequence_Parentheses(context, (Parentheses) semanticObject); 
				return; 
			case IF22Package.PLUS:
				sequence_MathExp(context, (Plus) semanticObject); 
				return; 
			case IF22Package.QUESTION:
				sequence_Question(context, (Question) semanticObject); 
				return; 
			case IF22Package.SCENARIO:
				sequence_Scenario(context, (Scenario) semanticObject); 
				return; 
			case IF22Package.STORY:
				sequence_Story(context, (Story) semanticObject); 
				return; 
			case IF22Package.TARGET:
				sequence_Target(context, (Target) semanticObject); 
				return; 
			case IF22Package.TEXT_EXP:
				sequence_TextExp(context, (TextExp) semanticObject); 
				return; 
			case IF22Package.TEXT_LITERAL:
				sequence_TextLiteral(context, (TextLiteral) semanticObject); 
				return; 
			case IF22Package.THIS:
				sequence_This(context, (This) semanticObject); 
				return; 
			case IF22Package.TYPE_USAGE:
				sequence_TypeUsage(context, (TypeUsage) semanticObject); 
				return; 
			case IF22Package.VAR_USE:
				sequence_VarUse(context, (VarUse) semanticObject); 
				return; 
			case IF22Package.VARIABLE_DEF:
				sequence_VariableDef(context, (VariableDef) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Announce
	 *     Announce returns Announce
	 *     TargetTarget returns Announce
	 *
	 * Constraint:
	 *     (name=ID text=LogicExp target=Target)
	 * </pre>
	 */
	protected void sequence_Announce(ISerializationContext context, Announce semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.TARGET_TARGET__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.TARGET_TARGET__NAME));
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.ANNOUNCE__TEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.ANNOUNCE__TEXT));
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.ANNOUNCE__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.ANNOUNCE__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAnnounceAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAnnounceAccess().getTextLogicExpParserRuleCall_2_0(), semanticObject.getText());
		feeder.accept(grammarAccess.getAnnounceAccess().getTargetTargetParserRuleCall_3_0(), semanticObject.getTarget());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StringProducer returns Boolean
	 *     LogicExp returns Boolean
	 *     LogicExp.Equals_1_0_0_1 returns Boolean
	 *     LogicExp.NotEquals_1_0_1_1 returns Boolean
	 *     LogicExp.Less_1_0_2_1 returns Boolean
	 *     LogicExp.Greater_1_0_3_1 returns Boolean
	 *     LogicExp.LessOrEquals_1_0_4_1 returns Boolean
	 *     LogicExp.GreaterOrEquals_1_0_5_1 returns Boolean
	 *     LogicAndOR returns Boolean
	 *     LogicAndOR.And_1_0_0_1 returns Boolean
	 *     LogicAndOR.Or_1_0_1_1 returns Boolean
	 *     Boolean returns Boolean
	 *     MathExp returns Boolean
	 *     MathExp.Plus_1_0_0_1 returns Boolean
	 *     MathExp.Minus_1_0_1_1 returns Boolean
	 *     MultDivMathExp returns Boolean
	 *     MultDivMathExp.Multiplication_1_0_0_1 returns Boolean
	 *     MultDivMathExp.Division_1_0_1_1 returns Boolean
	 *     TextExp returns Boolean
	 *     TextExp.TextExp_1_0_1 returns Boolean
	 *     Primary returns Boolean
	 *
	 * Constraint:
	 *     val=BooleanValue
	 * </pre>
	 */
	protected void sequence_Boolean(ISerializationContext context, dk.sdu.frhou18.mdsd.iF22.Boolean semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.BOOLEAN__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.BOOLEAN__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanAccess().getValBooleanValueEnumRuleCall_1_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns End
	 *     End returns End
	 *     TargetTarget returns End
	 *
	 * Constraint:
	 *     (name=ID endMessage=LogicExp)
	 * </pre>
	 */
	protected void sequence_End(ISerializationContext context, End semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.TARGET_TARGET__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.TARGET_TARGET__NAME));
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.END__END_MESSAGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.END__END_MESSAGE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEndAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getEndAccess().getEndMessageLogicExpParserRuleCall_2_0(), semanticObject.getEndMessage());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StringProducer returns FunctionUsage
	 *     LogicExp returns FunctionUsage
	 *     LogicExp.Equals_1_0_0_1 returns FunctionUsage
	 *     LogicExp.NotEquals_1_0_1_1 returns FunctionUsage
	 *     LogicExp.Less_1_0_2_1 returns FunctionUsage
	 *     LogicExp.Greater_1_0_3_1 returns FunctionUsage
	 *     LogicExp.LessOrEquals_1_0_4_1 returns FunctionUsage
	 *     LogicExp.GreaterOrEquals_1_0_5_1 returns FunctionUsage
	 *     LogicAndOR returns FunctionUsage
	 *     LogicAndOR.And_1_0_0_1 returns FunctionUsage
	 *     LogicAndOR.Or_1_0_1_1 returns FunctionUsage
	 *     MathExp returns FunctionUsage
	 *     MathExp.Plus_1_0_0_1 returns FunctionUsage
	 *     MathExp.Minus_1_0_1_1 returns FunctionUsage
	 *     MultDivMathExp returns FunctionUsage
	 *     MultDivMathExp.Multiplication_1_0_0_1 returns FunctionUsage
	 *     MultDivMathExp.Division_1_0_1_1 returns FunctionUsage
	 *     TextExp returns FunctionUsage
	 *     TextExp.TextExp_1_0_1 returns FunctionUsage
	 *     Primary returns FunctionUsage
	 *     FunctionUsage returns FunctionUsage
	 *
	 * Constraint:
	 *     (name=[Function|ID] exps+=LogicExp exps+=LogicExp*)
	 * </pre>
	 */
	protected void sequence_FunctionUsage(ISerializationContext context, FunctionUsage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Function returns Function
	 *
	 * Constraint:
	 *     (name=ID (parameters+=TypeUsage parameters+=TypeUsage*)? type=Type)
	 * </pre>
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicExp returns And
	 *     LogicExp.Equals_1_0_0_1 returns And
	 *     LogicExp.NotEquals_1_0_1_1 returns And
	 *     LogicExp.Less_1_0_2_1 returns And
	 *     LogicExp.Greater_1_0_3_1 returns And
	 *     LogicExp.LessOrEquals_1_0_4_1 returns And
	 *     LogicExp.GreaterOrEquals_1_0_5_1 returns And
	 *     LogicAndOR returns And
	 *     LogicAndOR.And_1_0_0_1 returns And
	 *     LogicAndOR.Or_1_0_1_1 returns And
	 *
	 * Constraint:
	 *     (left=LogicAndOR_And_1_0_0_1 right=MathExp)
	 * </pre>
	 */
	protected void sequence_LogicAndOR(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicAndORAccess().getAndLeftAction_1_0_0_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLogicAndORAccess().getRightMathExpParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicExp returns Or
	 *     LogicExp.Equals_1_0_0_1 returns Or
	 *     LogicExp.NotEquals_1_0_1_1 returns Or
	 *     LogicExp.Less_1_0_2_1 returns Or
	 *     LogicExp.Greater_1_0_3_1 returns Or
	 *     LogicExp.LessOrEquals_1_0_4_1 returns Or
	 *     LogicExp.GreaterOrEquals_1_0_5_1 returns Or
	 *     LogicAndOR returns Or
	 *     LogicAndOR.And_1_0_0_1 returns Or
	 *     LogicAndOR.Or_1_0_1_1 returns Or
	 *
	 * Constraint:
	 *     (left=LogicAndOR_Or_1_0_1_1 right=MathExp)
	 * </pre>
	 */
	protected void sequence_LogicAndOR(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicAndORAccess().getOrLeftAction_1_0_1_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLogicAndORAccess().getRightMathExpParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicExp returns Equals
	 *     LogicExp.Equals_1_0_0_1 returns Equals
	 *     LogicExp.NotEquals_1_0_1_1 returns Equals
	 *     LogicExp.Less_1_0_2_1 returns Equals
	 *     LogicExp.Greater_1_0_3_1 returns Equals
	 *     LogicExp.LessOrEquals_1_0_4_1 returns Equals
	 *     LogicExp.GreaterOrEquals_1_0_5_1 returns Equals
	 *
	 * Constraint:
	 *     (left=LogicExp_Equals_1_0_0_1 right=LogicAndOR)
	 * </pre>
	 */
	protected void sequence_LogicExp(ISerializationContext context, Equals semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.EQUALS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.EQUALS__LEFT));
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.EQUALS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.EQUALS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicExpAccess().getEqualsLeftAction_1_0_0_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLogicExpAccess().getRightLogicAndORParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicExp returns Greater
	 *     LogicExp.Equals_1_0_0_1 returns Greater
	 *     LogicExp.NotEquals_1_0_1_1 returns Greater
	 *     LogicExp.Less_1_0_2_1 returns Greater
	 *     LogicExp.Greater_1_0_3_1 returns Greater
	 *     LogicExp.LessOrEquals_1_0_4_1 returns Greater
	 *     LogicExp.GreaterOrEquals_1_0_5_1 returns Greater
	 *
	 * Constraint:
	 *     (left=LogicExp_Greater_1_0_3_1 right=LogicAndOR)
	 * </pre>
	 */
	protected void sequence_LogicExp(ISerializationContext context, Greater semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.GREATER__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.GREATER__LEFT));
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.GREATER__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.GREATER__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicExpAccess().getGreaterLeftAction_1_0_3_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLogicExpAccess().getRightLogicAndORParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicExp returns GreaterOrEquals
	 *     LogicExp.Equals_1_0_0_1 returns GreaterOrEquals
	 *     LogicExp.NotEquals_1_0_1_1 returns GreaterOrEquals
	 *     LogicExp.Less_1_0_2_1 returns GreaterOrEquals
	 *     LogicExp.Greater_1_0_3_1 returns GreaterOrEquals
	 *     LogicExp.LessOrEquals_1_0_4_1 returns GreaterOrEquals
	 *     LogicExp.GreaterOrEquals_1_0_5_1 returns GreaterOrEquals
	 *
	 * Constraint:
	 *     (left=LogicExp_GreaterOrEquals_1_0_5_1 right=LogicAndOR)
	 * </pre>
	 */
	protected void sequence_LogicExp(ISerializationContext context, GreaterOrEquals semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.GREATER_OR_EQUALS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.GREATER_OR_EQUALS__LEFT));
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.GREATER_OR_EQUALS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.GREATER_OR_EQUALS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicExpAccess().getGreaterOrEqualsLeftAction_1_0_5_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLogicExpAccess().getRightLogicAndORParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicExp returns Less
	 *     LogicExp.Equals_1_0_0_1 returns Less
	 *     LogicExp.NotEquals_1_0_1_1 returns Less
	 *     LogicExp.Less_1_0_2_1 returns Less
	 *     LogicExp.Greater_1_0_3_1 returns Less
	 *     LogicExp.LessOrEquals_1_0_4_1 returns Less
	 *     LogicExp.GreaterOrEquals_1_0_5_1 returns Less
	 *
	 * Constraint:
	 *     (left=LogicExp_Less_1_0_2_1 right=LogicAndOR)
	 * </pre>
	 */
	protected void sequence_LogicExp(ISerializationContext context, Less semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.LESS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.LESS__LEFT));
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.LESS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.LESS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicExpAccess().getLessLeftAction_1_0_2_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLogicExpAccess().getRightLogicAndORParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicExp returns LessOrEquals
	 *     LogicExp.Equals_1_0_0_1 returns LessOrEquals
	 *     LogicExp.NotEquals_1_0_1_1 returns LessOrEquals
	 *     LogicExp.Less_1_0_2_1 returns LessOrEquals
	 *     LogicExp.Greater_1_0_3_1 returns LessOrEquals
	 *     LogicExp.LessOrEquals_1_0_4_1 returns LessOrEquals
	 *     LogicExp.GreaterOrEquals_1_0_5_1 returns LessOrEquals
	 *
	 * Constraint:
	 *     (left=LogicExp_LessOrEquals_1_0_4_1 right=LogicAndOR)
	 * </pre>
	 */
	protected void sequence_LogicExp(ISerializationContext context, LessOrEquals semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.LESS_OR_EQUALS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.LESS_OR_EQUALS__LEFT));
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.LESS_OR_EQUALS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.LESS_OR_EQUALS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicExpAccess().getLessOrEqualsLeftAction_1_0_4_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLogicExpAccess().getRightLogicAndORParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicExp returns NotEquals
	 *     LogicExp.Equals_1_0_0_1 returns NotEquals
	 *     LogicExp.NotEquals_1_0_1_1 returns NotEquals
	 *     LogicExp.Less_1_0_2_1 returns NotEquals
	 *     LogicExp.Greater_1_0_3_1 returns NotEquals
	 *     LogicExp.LessOrEquals_1_0_4_1 returns NotEquals
	 *     LogicExp.GreaterOrEquals_1_0_5_1 returns NotEquals
	 *
	 * Constraint:
	 *     (left=LogicExp_NotEquals_1_0_1_1 right=LogicAndOR)
	 * </pre>
	 */
	protected void sequence_LogicExp(ISerializationContext context, NotEquals semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.NOT_EQUALS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.NOT_EQUALS__LEFT));
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.NOT_EQUALS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.NOT_EQUALS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicExpAccess().getNotEqualsLeftAction_1_0_1_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLogicExpAccess().getRightLogicAndORParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StringProducer returns LogicNot
	 *     LogicExp returns LogicNot
	 *     LogicExp.Equals_1_0_0_1 returns LogicNot
	 *     LogicExp.NotEquals_1_0_1_1 returns LogicNot
	 *     LogicExp.Less_1_0_2_1 returns LogicNot
	 *     LogicExp.Greater_1_0_3_1 returns LogicNot
	 *     LogicExp.LessOrEquals_1_0_4_1 returns LogicNot
	 *     LogicExp.GreaterOrEquals_1_0_5_1 returns LogicNot
	 *     LogicAndOR returns LogicNot
	 *     LogicAndOR.And_1_0_0_1 returns LogicNot
	 *     LogicAndOR.Or_1_0_1_1 returns LogicNot
	 *     LogicNot returns LogicNot
	 *     MathExp returns LogicNot
	 *     MathExp.Plus_1_0_0_1 returns LogicNot
	 *     MathExp.Minus_1_0_1_1 returns LogicNot
	 *     MultDivMathExp returns LogicNot
	 *     MultDivMathExp.Multiplication_1_0_0_1 returns LogicNot
	 *     MultDivMathExp.Division_1_0_1_1 returns LogicNot
	 *     TextExp returns LogicNot
	 *     TextExp.TextExp_1_0_1 returns LogicNot
	 *     Primary returns LogicNot
	 *
	 * Constraint:
	 *     ref=Primary
	 * </pre>
	 */
	protected void sequence_LogicNot(ISerializationContext context, LogicNot semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.LOGIC_NOT__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.LOGIC_NOT__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicNotAccess().getRefPrimaryParserRuleCall_2_0(), semanticObject.getRef());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicExp returns Minus
	 *     LogicExp.Equals_1_0_0_1 returns Minus
	 *     LogicExp.NotEquals_1_0_1_1 returns Minus
	 *     LogicExp.Less_1_0_2_1 returns Minus
	 *     LogicExp.Greater_1_0_3_1 returns Minus
	 *     LogicExp.LessOrEquals_1_0_4_1 returns Minus
	 *     LogicExp.GreaterOrEquals_1_0_5_1 returns Minus
	 *     LogicAndOR returns Minus
	 *     LogicAndOR.And_1_0_0_1 returns Minus
	 *     LogicAndOR.Or_1_0_1_1 returns Minus
	 *     MathExp returns Minus
	 *     MathExp.Plus_1_0_0_1 returns Minus
	 *     MathExp.Minus_1_0_1_1 returns Minus
	 *
	 * Constraint:
	 *     (left=MathExp_Minus_1_0_1_1 right=MultDivMathExp)
	 * </pre>
	 */
	protected void sequence_MathExp(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.MINUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.MINUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.MINUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.MINUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMathExpAccess().getMinusLeftAction_1_0_1_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMathExpAccess().getRightMultDivMathExpParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicExp returns Plus
	 *     LogicExp.Equals_1_0_0_1 returns Plus
	 *     LogicExp.NotEquals_1_0_1_1 returns Plus
	 *     LogicExp.Less_1_0_2_1 returns Plus
	 *     LogicExp.Greater_1_0_3_1 returns Plus
	 *     LogicExp.LessOrEquals_1_0_4_1 returns Plus
	 *     LogicExp.GreaterOrEquals_1_0_5_1 returns Plus
	 *     LogicAndOR returns Plus
	 *     LogicAndOR.And_1_0_0_1 returns Plus
	 *     LogicAndOR.Or_1_0_1_1 returns Plus
	 *     MathExp returns Plus
	 *     MathExp.Plus_1_0_0_1 returns Plus
	 *     MathExp.Minus_1_0_1_1 returns Plus
	 *
	 * Constraint:
	 *     (left=MathExp_Plus_1_0_0_1 right=MultDivMathExp)
	 * </pre>
	 */
	protected void sequence_MathExp(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.PLUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.PLUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.PLUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.PLUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMathExpAccess().getPlusLeftAction_1_0_0_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMathExpAccess().getRightMultDivMathExpParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StringProducer returns MathNumberExp
	 *     LogicExp returns MathNumberExp
	 *     LogicExp.Equals_1_0_0_1 returns MathNumberExp
	 *     LogicExp.NotEquals_1_0_1_1 returns MathNumberExp
	 *     LogicExp.Less_1_0_2_1 returns MathNumberExp
	 *     LogicExp.Greater_1_0_3_1 returns MathNumberExp
	 *     LogicExp.LessOrEquals_1_0_4_1 returns MathNumberExp
	 *     LogicExp.GreaterOrEquals_1_0_5_1 returns MathNumberExp
	 *     LogicAndOR returns MathNumberExp
	 *     LogicAndOR.And_1_0_0_1 returns MathNumberExp
	 *     LogicAndOR.Or_1_0_1_1 returns MathNumberExp
	 *     MathExp returns MathNumberExp
	 *     MathExp.Plus_1_0_0_1 returns MathNumberExp
	 *     MathExp.Minus_1_0_1_1 returns MathNumberExp
	 *     MultDivMathExp returns MathNumberExp
	 *     MultDivMathExp.Multiplication_1_0_0_1 returns MathNumberExp
	 *     MultDivMathExp.Division_1_0_1_1 returns MathNumberExp
	 *     MathNumberExp returns MathNumberExp
	 *     TextExp returns MathNumberExp
	 *     TextExp.TextExp_1_0_1 returns MathNumberExp
	 *     Primary returns MathNumberExp
	 *
	 * Constraint:
	 *     value=INT
	 * </pre>
	 */
	protected void sequence_MathNumberExp(ISerializationContext context, MathNumberExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.MATH_NUMBER_EXP__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.MATH_NUMBER_EXP__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMathNumberExpAccess().getValueINTTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (storyName=Story functions+=Function* scenarios+=Scenario+)
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicExp returns Division
	 *     LogicExp.Equals_1_0_0_1 returns Division
	 *     LogicExp.NotEquals_1_0_1_1 returns Division
	 *     LogicExp.Less_1_0_2_1 returns Division
	 *     LogicExp.Greater_1_0_3_1 returns Division
	 *     LogicExp.LessOrEquals_1_0_4_1 returns Division
	 *     LogicExp.GreaterOrEquals_1_0_5_1 returns Division
	 *     LogicAndOR returns Division
	 *     LogicAndOR.And_1_0_0_1 returns Division
	 *     LogicAndOR.Or_1_0_1_1 returns Division
	 *     MathExp returns Division
	 *     MathExp.Plus_1_0_0_1 returns Division
	 *     MathExp.Minus_1_0_1_1 returns Division
	 *     MultDivMathExp returns Division
	 *     MultDivMathExp.Multiplication_1_0_0_1 returns Division
	 *     MultDivMathExp.Division_1_0_1_1 returns Division
	 *
	 * Constraint:
	 *     (left=MultDivMathExp_Division_1_0_1_1 right=TextExp)
	 * </pre>
	 */
	protected void sequence_MultDivMathExp(ISerializationContext context, Division semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.DIVISION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.DIVISION__LEFT));
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.DIVISION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.DIVISION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultDivMathExpAccess().getDivisionLeftAction_1_0_1_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultDivMathExpAccess().getRightTextExpParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicExp returns Multiplication
	 *     LogicExp.Equals_1_0_0_1 returns Multiplication
	 *     LogicExp.NotEquals_1_0_1_1 returns Multiplication
	 *     LogicExp.Less_1_0_2_1 returns Multiplication
	 *     LogicExp.Greater_1_0_3_1 returns Multiplication
	 *     LogicExp.LessOrEquals_1_0_4_1 returns Multiplication
	 *     LogicExp.GreaterOrEquals_1_0_5_1 returns Multiplication
	 *     LogicAndOR returns Multiplication
	 *     LogicAndOR.And_1_0_0_1 returns Multiplication
	 *     LogicAndOR.Or_1_0_1_1 returns Multiplication
	 *     MathExp returns Multiplication
	 *     MathExp.Plus_1_0_0_1 returns Multiplication
	 *     MathExp.Minus_1_0_1_1 returns Multiplication
	 *     MultDivMathExp returns Multiplication
	 *     MultDivMathExp.Multiplication_1_0_0_1 returns Multiplication
	 *     MultDivMathExp.Division_1_0_1_1 returns Multiplication
	 *
	 * Constraint:
	 *     (left=MultDivMathExp_Multiplication_1_0_0_1 right=TextExp)
	 * </pre>
	 */
	protected void sequence_MultDivMathExp(ISerializationContext context, Multiplication semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.MULTIPLICATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.MULTIPLICATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.MULTIPLICATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.MULTIPLICATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultDivMathExpAccess().getMultiplicationLeftAction_1_0_0_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultDivMathExpAccess().getRightTextExpParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StringProducer returns Parentheses
	 *     LogicExp returns Parentheses
	 *     LogicExp.Equals_1_0_0_1 returns Parentheses
	 *     LogicExp.NotEquals_1_0_1_1 returns Parentheses
	 *     LogicExp.Less_1_0_2_1 returns Parentheses
	 *     LogicExp.Greater_1_0_3_1 returns Parentheses
	 *     LogicExp.LessOrEquals_1_0_4_1 returns Parentheses
	 *     LogicExp.GreaterOrEquals_1_0_5_1 returns Parentheses
	 *     LogicAndOR returns Parentheses
	 *     LogicAndOR.And_1_0_0_1 returns Parentheses
	 *     LogicAndOR.Or_1_0_1_1 returns Parentheses
	 *     Parentheses returns Parentheses
	 *     MathExp returns Parentheses
	 *     MathExp.Plus_1_0_0_1 returns Parentheses
	 *     MathExp.Minus_1_0_1_1 returns Parentheses
	 *     MultDivMathExp returns Parentheses
	 *     MultDivMathExp.Multiplication_1_0_0_1 returns Parentheses
	 *     MultDivMathExp.Division_1_0_1_1 returns Parentheses
	 *     TextExp returns Parentheses
	 *     TextExp.TextExp_1_0_1 returns Parentheses
	 *     Primary returns Parentheses
	 *
	 * Constraint:
	 *     ref=LogicExp
	 * </pre>
	 */
	protected void sequence_Parentheses(ISerializationContext context, Parentheses semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.PARENTHESES__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.PARENTHESES__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParenthesesAccess().getRefLogicExpParserRuleCall_2_0(), semanticObject.getRef());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Question
	 *     Question returns Question
	 *     TargetTarget returns Question
	 *
	 * Constraint:
	 *     (name=ID text=LogicExp asValue=LogicExp inVar=VarUse? targets+=Target+)
	 * </pre>
	 */
	protected void sequence_Question(ISerializationContext context, Question semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Scenario returns Scenario
	 *     TargetTarget returns Scenario
	 *
	 * Constraint:
	 *     (name=ID variables+=VariableDef* statemens+=Statement*)
	 * </pre>
	 */
	protected void sequence_Scenario(ISerializationContext context, Scenario semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Story returns Story
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_Story(ISerializationContext context, Story semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.STORY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.STORY__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStoryAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Target returns Target
	 *
	 * Constraint:
	 *     (target=[TargetTarget|ID] logic=LogicExp?)
	 * </pre>
	 */
	protected void sequence_Target(ISerializationContext context, Target semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StringProducer returns TextExp
	 *     LogicExp returns TextExp
	 *     LogicExp.Equals_1_0_0_1 returns TextExp
	 *     LogicExp.NotEquals_1_0_1_1 returns TextExp
	 *     LogicExp.Less_1_0_2_1 returns TextExp
	 *     LogicExp.Greater_1_0_3_1 returns TextExp
	 *     LogicExp.LessOrEquals_1_0_4_1 returns TextExp
	 *     LogicExp.GreaterOrEquals_1_0_5_1 returns TextExp
	 *     LogicAndOR returns TextExp
	 *     LogicAndOR.And_1_0_0_1 returns TextExp
	 *     LogicAndOR.Or_1_0_1_1 returns TextExp
	 *     MathExp returns TextExp
	 *     MathExp.Plus_1_0_0_1 returns TextExp
	 *     MathExp.Minus_1_0_1_1 returns TextExp
	 *     MultDivMathExp returns TextExp
	 *     MultDivMathExp.Multiplication_1_0_0_1 returns TextExp
	 *     MultDivMathExp.Division_1_0_1_1 returns TextExp
	 *     TextExp returns TextExp
	 *     TextExp.TextExp_1_0_1 returns TextExp
	 *
	 * Constraint:
	 *     (left=TextExp_TextExp_1_0_1 right=Primary)
	 * </pre>
	 */
	protected void sequence_TextExp(ISerializationContext context, TextExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.TEXT_EXP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.TEXT_EXP__LEFT));
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.TEXT_EXP__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.TEXT_EXP__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTextExpAccess().getTextExpLeftAction_1_0_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getTextExpAccess().getRightPrimaryParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StringProducer returns TextLiteral
	 *     LogicExp returns TextLiteral
	 *     LogicExp.Equals_1_0_0_1 returns TextLiteral
	 *     LogicExp.NotEquals_1_0_1_1 returns TextLiteral
	 *     LogicExp.Less_1_0_2_1 returns TextLiteral
	 *     LogicExp.Greater_1_0_3_1 returns TextLiteral
	 *     LogicExp.LessOrEquals_1_0_4_1 returns TextLiteral
	 *     LogicExp.GreaterOrEquals_1_0_5_1 returns TextLiteral
	 *     LogicAndOR returns TextLiteral
	 *     LogicAndOR.And_1_0_0_1 returns TextLiteral
	 *     LogicAndOR.Or_1_0_1_1 returns TextLiteral
	 *     MathExp returns TextLiteral
	 *     MathExp.Plus_1_0_0_1 returns TextLiteral
	 *     MathExp.Minus_1_0_1_1 returns TextLiteral
	 *     MultDivMathExp returns TextLiteral
	 *     MultDivMathExp.Multiplication_1_0_0_1 returns TextLiteral
	 *     MultDivMathExp.Division_1_0_1_1 returns TextLiteral
	 *     TextExp returns TextLiteral
	 *     TextExp.TextExp_1_0_1 returns TextLiteral
	 *     Primary returns TextLiteral
	 *     TextLiteral returns TextLiteral
	 *
	 * Constraint:
	 *     text=STRING
	 * </pre>
	 */
	protected void sequence_TextLiteral(ISerializationContext context, TextLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.TEXT_LITERAL__TEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.TEXT_LITERAL__TEXT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTextLiteralAccess().getTextSTRINGTerminalRuleCall_1_0(), semanticObject.getText());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StringProducer returns This
	 *     This returns This
	 *     LogicExp returns This
	 *     LogicExp.Equals_1_0_0_1 returns This
	 *     LogicExp.NotEquals_1_0_1_1 returns This
	 *     LogicExp.Less_1_0_2_1 returns This
	 *     LogicExp.Greater_1_0_3_1 returns This
	 *     LogicExp.LessOrEquals_1_0_4_1 returns This
	 *     LogicExp.GreaterOrEquals_1_0_5_1 returns This
	 *     LogicAndOR returns This
	 *     LogicAndOR.And_1_0_0_1 returns This
	 *     LogicAndOR.Or_1_0_1_1 returns This
	 *     MathExp returns This
	 *     MathExp.Plus_1_0_0_1 returns This
	 *     MathExp.Minus_1_0_1_1 returns This
	 *     MultDivMathExp returns This
	 *     MultDivMathExp.Multiplication_1_0_0_1 returns This
	 *     MultDivMathExp.Division_1_0_1_1 returns This
	 *     TextExp returns This
	 *     TextExp.TextExp_1_0_1 returns This
	 *     Primary returns This
	 *
	 * Constraint:
	 *     {This}
	 * </pre>
	 */
	protected void sequence_This(ISerializationContext context, This semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StringProducer returns TypeUsage
	 *     LogicExp returns TypeUsage
	 *     LogicExp.Equals_1_0_0_1 returns TypeUsage
	 *     LogicExp.NotEquals_1_0_1_1 returns TypeUsage
	 *     LogicExp.Less_1_0_2_1 returns TypeUsage
	 *     LogicExp.Greater_1_0_3_1 returns TypeUsage
	 *     LogicExp.LessOrEquals_1_0_4_1 returns TypeUsage
	 *     LogicExp.GreaterOrEquals_1_0_5_1 returns TypeUsage
	 *     LogicAndOR returns TypeUsage
	 *     LogicAndOR.And_1_0_0_1 returns TypeUsage
	 *     LogicAndOR.Or_1_0_1_1 returns TypeUsage
	 *     MathExp returns TypeUsage
	 *     MathExp.Plus_1_0_0_1 returns TypeUsage
	 *     MathExp.Minus_1_0_1_1 returns TypeUsage
	 *     MultDivMathExp returns TypeUsage
	 *     MultDivMathExp.Multiplication_1_0_0_1 returns TypeUsage
	 *     MultDivMathExp.Division_1_0_1_1 returns TypeUsage
	 *     TextExp returns TypeUsage
	 *     TextExp.TextExp_1_0_1 returns TypeUsage
	 *     Primary returns TypeUsage
	 *     TypeUsage returns TypeUsage
	 *
	 * Constraint:
	 *     type=Type
	 * </pre>
	 */
	protected void sequence_TypeUsage(ISerializationContext context, TypeUsage semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.TYPE_USAGE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.TYPE_USAGE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeUsageAccess().getTypeTypeEnumRuleCall_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StringProducer returns VarUse
	 *     LogicExp returns VarUse
	 *     LogicExp.Equals_1_0_0_1 returns VarUse
	 *     LogicExp.NotEquals_1_0_1_1 returns VarUse
	 *     LogicExp.Less_1_0_2_1 returns VarUse
	 *     LogicExp.Greater_1_0_3_1 returns VarUse
	 *     LogicExp.LessOrEquals_1_0_4_1 returns VarUse
	 *     LogicExp.GreaterOrEquals_1_0_5_1 returns VarUse
	 *     LogicAndOR returns VarUse
	 *     LogicAndOR.And_1_0_0_1 returns VarUse
	 *     LogicAndOR.Or_1_0_1_1 returns VarUse
	 *     MathExp returns VarUse
	 *     MathExp.Plus_1_0_0_1 returns VarUse
	 *     MathExp.Minus_1_0_1_1 returns VarUse
	 *     MultDivMathExp returns VarUse
	 *     MultDivMathExp.Multiplication_1_0_0_1 returns VarUse
	 *     MultDivMathExp.Division_1_0_1_1 returns VarUse
	 *     TextExp returns VarUse
	 *     TextExp.TextExp_1_0_1 returns VarUse
	 *     Primary returns VarUse
	 *     VarUse returns VarUse
	 *
	 * Constraint:
	 *     ref=[VariableDef|ID]
	 * </pre>
	 */
	protected void sequence_VarUse(ISerializationContext context, VarUse semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.VAR_USE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.VAR_USE__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarUseAccess().getRefVariableDefIDTerminalRuleCall_1_0_1(), semanticObject.eGet(IF22Package.Literals.VAR_USE__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VariableDef returns VariableDef
	 *
	 * Constraint:
	 *     (name=ID type=Type)
	 * </pre>
	 */
	protected void sequence_VariableDef(ISerializationContext context, VariableDef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.VARIABLE_DEF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.VARIABLE_DEF__NAME));
			if (transientValues.isValueTransient(semanticObject, IF22Package.Literals.VARIABLE_DEF__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IF22Package.Literals.VARIABLE_DEF__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableDefAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVariableDefAccess().getTypeTypeEnumRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
}
