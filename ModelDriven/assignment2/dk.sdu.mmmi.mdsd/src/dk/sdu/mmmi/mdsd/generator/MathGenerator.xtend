/*
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.generator

import dk.sdu.mmmi.mdsd.math.Division
import dk.sdu.mmmi.mdsd.math.ExplicitNumber
import dk.sdu.mmmi.mdsd.math.Expression
import dk.sdu.mmmi.mdsd.math.Minus
import dk.sdu.mmmi.mdsd.math.Multiplication
import dk.sdu.mmmi.mdsd.math.Parenthesis
import dk.sdu.mmmi.mdsd.math.Plus
import dk.sdu.mmmi.mdsd.math.VarUse
import dk.sdu.mmmi.mdsd.math.Variable
import dk.sdu.mmmi.mdsd.math.Variables
import java.util.HashMap
import java.util.Map
import javax.swing.JOptionPane
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import dk.sdu.mmmi.mdsd.math.VariableAssignment
import dk.sdu.mmmi.mdsd.math.Local

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathGenerator extends AbstractGenerator {

	static Map<String, Integer> variables = new HashMap();
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val lines = resource.allContents.filter(Variables).next
		val result = lines.compute
		
		// You can replace with hovering, see Bettini Chapter 8
		result.displayPanel
	}
	
	def static Map<String, Integer> compute(Variables math){
		var values = new HashMap<String, Integer>
		for (varass : math.getVariableAssignments()) {
			values.put(varass.getName(), ComputeExp(varass, values))
		}
		return values
	}

	//Plus
	def static dispatch Integer ComputeExp(Plus exp, Map<String, Integer> env) {
		return exp.left.ComputeExp(env) + exp.right.ComputeExp(env)
	}
	//Minus
	def static dispatch Integer ComputeExp(Minus exp, Map<String, Integer> env) {
		return exp.left.ComputeExp(env) - exp.right.ComputeExp(env)
	}
	//Multiplication
	def static dispatch Integer ComputeExp(Multiplication exp, Map<String, Integer> env) {
		return exp.left.ComputeExp(env) * exp.right.ComputeExp(env)
	}
	//Division
	def static dispatch Integer ComputeExp(Division exp, Map<String, Integer> env) {
		return exp.left.ComputeExp(env) / exp.right.ComputeExp(env)
	}
	//ExplicitNumber
	def static dispatch Integer ComputeExp(ExplicitNumber exp, Map<String, Integer> env) {
		return exp.value
	}
	//Parenthesis
	def static dispatch Integer ComputeExp(Parenthesis exp, Map<String, Integer> env) {
		return exp.getExp.ComputeExp(env)
	}
	//VarUse
	def static dispatch Integer ComputeExp(VarUse exp, Map<String, Integer> env) {
		return env.getOrDefault(exp.ref.name, exp.ref.ComputeExp(env))
	}
	//Let
	def static dispatch Integer ComputeExp(Local exp, Map<String, Integer> env) { //Let
		return env.getOrDefault(exp.assignment.name, ComputeExp(exp.exp, generateLocalEnv(env, exp.assignment.name, exp.assignment.exp.ComputeExp(env))));
	}
	//Variable
	def static dispatch Integer ComputeExp(Variable exp, Map<String, Integer> env) {
		return env.getOrDefault(exp.name, exp.exp.ComputeExp(env))
	}	
	
	static def Map<String, Integer> generateLocalEnv (Map<String, Integer> givenEnvironment, String localVarName, int bodyValue){
		val newEnvironment = new HashMap<String, Integer>(givenEnvironment)
		
		newEnvironment.put(localVarName, bodyValue)
		print("Localvar: "+localVarName+" Value: " + bodyValue + "\n")
		return newEnvironment
	}
	
	def void displayPanel(Map<String, Integer> result) {
		var resultString = ""
		for (entry : result.entrySet()) {
         	resultString += "var " + entry.getKey() + " = " + entry.getValue() + "\n"
        }
		
		JOptionPane.showMessageDialog(null, resultString ,"Math Language", JOptionPane.INFORMATION_MESSAGE)
	}
}
