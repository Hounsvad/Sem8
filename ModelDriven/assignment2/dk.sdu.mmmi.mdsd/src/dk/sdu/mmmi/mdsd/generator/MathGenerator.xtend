/*
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.generator

import dk.sdu.mmmi.mdsd.math.Division
import dk.sdu.mmmi.mdsd.math.Minus
import dk.sdu.mmmi.mdsd.math.Multiplication
import dk.sdu.mmmi.mdsd.math.Plus
import dk.sdu.mmmi.mdsd.math.Expression
import java.util.HashMap
import java.util.Map
import javax.swing.JOptionPane
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import dk.sdu.mmmi.mdsd.math.ExplicitNumber
import dk.sdu.mmmi.mdsd.math.Let
import dk.sdu.mmmi.mdsd.math.VarUse
import dk.sdu.mmmi.mdsd.math.Variables
import dk.sdu.mmmi.mdsd.math.Parenthesis
import dk.sdu.mmmi.mdsd.math.Variable

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathGenerator extends AbstractGenerator {

	static Map<String, Integer> variables = new HashMap();
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val lines = resource.allContents.filter(Variables).next
		//lines.printInterpretedExpressions
		val result = lines.compute
		
		// You can replace with hovering, see Bettini Chapter 8
		result.displayPanel
	}
		
	def void printInterpretedExpressions(Variables variables){
		for (varass : variables.getVariableAssignments()){
			displayExpression(varass)
		}
	}
	
	//
	// Compute function: computes value of expression
	// Note: written according to illegal left-recursive grammar, requires fix
	//
	
	def static Map<String, Integer> compute(Variables math){
		var values = new HashMap<String, Integer>
		for (varass : math.getVariableAssignments()) {
			values.put(varass.getName(), computeIndividual(varass, values))
		}
		values
	}
	
	def static int computeIndividual(Variable varAss, Map<String, Integer> environment) { 
		varAss.ref.computeExp(environment)
	}
	
	def static int computeExp(Expression exp, Map<String, Integer> env) {
		switch exp {
			Plus: exp.left.computeExp(env)+exp.right.computeExp(env)
			Minus: exp.left.computeExp(env)-exp.right.computeExp(env)
			Multiplication: exp.left.computeExp(env)*exp.right.computeExp(env)
			Division: exp.left.computeExp(env)/exp.right.computeExp(env)
			ExplicitNumber: exp.value
			Parenthesis: exp.getExp.computeExp(env)
			VarUse: env.getOrDefault(exp.ref.name, exp.ref.computeExp(env))
			Let: {
				if(env.get(exp.name) == null)
					computeExp(exp.getBody(), generateLetEnv(env, exp.getName(), exp.getExp().computeExp(env)))
				else
					env.get(exp.name)
			}
			Variable: env.getOrDefault(exp.name, exp.ref.computeExp(env))
			default: throw new Error("Invalid Expression: " + exp)
		}
	}
	
	static def Map<String, Integer> generateLetEnv (Map<String, Integer> givenEnvironment, String letVarName, int bodyValue){
		val newEnvironment = new HashMap<String, Integer>(givenEnvironment)
		
		newEnvironment.put(letVarName, bodyValue)
		print("Letvar: "+letVarName+" Value: " + bodyValue + "\n")
		newEnvironment
	}
	
//	def static int computePrim(Primary factor) { 
//		87
//	}

	def void displayPanel(Map<String, Integer> result) {
		var resultString = ""
		for (entry : result.entrySet()) {
         	resultString += "var " + entry.getKey() + " = " + entry.getValue() + "\n"
        }
		
		JOptionPane.showMessageDialog(null, resultString ,"Math Language", JOptionPane.INFORMATION_MESSAGE)
	}
	
	def displayExpression(Variable varAss){
		print(varAss.ref.getExpressionString + "\n")
	}
	
	def String getExpressionString(Expression exp){
		switch exp {
			Plus: exp.left.getExpressionString +"+"+exp.right.getExpressionString
			Minus: exp.left.getExpressionString+"-"+exp.right.getExpressionString
			Multiplication: exp.left.getExpressionString+"*"+exp.right.getExpressionString
			Division: exp.left.getExpressionString+"/"+exp.right.getExpressionString
			ExplicitNumber: Integer.toString(exp.value)
			Parenthesis: exp.getExp.getExpressionString
			Let: '''let «exp.name» = «exp.exp.getExpressionString» in «exp.body.getExpressionString»'''
			VarUse: exp.ref.getExpressionString
			Variable: exp.getName()
			default: throw new Error("Invalid Expression: " + exp)
		}
	}

}
